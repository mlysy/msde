<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Martin Lysy, JunYong Tong, Nigel Delaney" />

<meta name="date" content="2018-02-01" />

<title>Inference for Multivariate Stochastic Differential Equations with msde</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Inference for Multivariate Stochastic Differential Equations with <strong><code>msde</code></strong></h1>
<h4 class="author"><em>Martin Lysy, JunYong Tong, Nigel Delaney</em></h4>
<h4 class="date"><em>2018-02-01</em></h4>


<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#creating-an-sde.model-object">Creating an <code>sde.model</code> object</a><ul>
<li><a href="#the-sdemodel-class-definition">The <code>sdeModel</code> class definition</a></li>
<li><a href="#compiling-and-checking-the-sde.model-object">Compiling and checking the <code>sde.model</code> object</a></li>
</ul></li>
<li><a href="#simulating-trajectories-from-the-lotka-volterra-model">Simulating trajectories from the Lotka-Volterra model</a></li>
<li><a href="#inference-for-multivariate-sde-models">Inference for multivariate SDE models</a><ul>
<li><a href="#missing-data-specification-with-sde.init">Missing data specification with <code>sde.init</code></a></li>
<li><a href="#defprior">Default prior specification</a></li>
</ul></li>
<li><a href="#custprior">Custom prior specification</a><ul>
<li><a href="#the-sdeprior-class-definition">The <code>sdePrior</code> class definition</a></li>
<li><a href="#formatting-the-r-input-to-the-c-code">Formatting the <strong>R</strong> input to the <strong>C++</strong> code</a></li>
<li><a href="#compiling-and-checking-the-prior">Compiling and checking the prior</a></li>
</ul></li>
<li><a href="#install">Installation</a><ul>
<li><a href="#enable-c-compiling-for-r">Enable <strong>C++</strong> compiling for <strong>R</strong></a></li>
<li><a href="#optimize-settings-for-the-c-compiler-optional">Optimize settings for the <strong>C++</strong> compiler (optional)</a></li>
<li><a href="#enable-openmp-support-optional">Enable <strong><code>OpenMP</code></strong> support (optional)</a></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>A <span class="math inline">\(d\)</span>-dimensional stochastic differential equation (SDE) <span class="math inline">\({{\boldsymbol{Y}}}_t = ({Y_{1t},\ldots,Y_{dt}})\)</span> is written as <span class="math display">\[
{\mathrm{d}}{{\boldsymbol{Y}}}_t = {{\boldsymbol{\Lambda}}}_{{{\boldsymbol{\theta}}}}({{\boldsymbol{Y}}}_t)\,{\mathrm{d}}t + {{\boldsymbol{\Sigma}}}_{{{\boldsymbol{\theta}}}}({{\boldsymbol{Y}}}_t)^{1/2}\,{\mathrm{d}}{{\boldsymbol{B}}}_t,
\]</span> where <span class="math inline">\({{\boldsymbol{\Lambda}}}_{{{\boldsymbol{\theta}}}}({{\boldsymbol{y}}})\)</span> and <span class="math inline">\({{\boldsymbol{\Sigma}}}_{{{\boldsymbol{\theta}}}}({{\boldsymbol{y}}})\)</span> are the drift and diffusion functions, <!-- $$ --> <!-- \dr_{\tth}(\y) = \lim_{\dt \to 0} \frac{E[\Y_{t+\dt} - \Y_t \mid \Y_t = \y]}{\dt}, \qquad \df_{\tth}(\y) = \lim_{\dt \to 0} \frac{\var(\Y_{t+\dt} - \Y_t \mid \Y_t = \y)}{\dt}, --> <!-- $$ --> and <span class="math inline">\({{\boldsymbol{B}}}_t = ({B_{1t},\ldots,B_{dt}})\)</span> is <span class="math inline">\(d\)</span>-dimensional Brownian motion. The <strong><code>msde</code></strong> package implements a Markov Chain Monte Carlo (MCMC) algorithm to sample from the posterior distribution <span class="math inline">\(p({{\boldsymbol{\theta}}}\mid {{\boldsymbol{Y}}})\)</span> of the parameters given discrete observations <span class="math inline">\({{\boldsymbol{Y}}}= ({{{\boldsymbol{Y}}}_{0},\ldots,{{\boldsymbol{Y}}}_{N}})\)</span> recorded at times <span class="math inline">\({t_{0},\ldots,t_{N}}\)</span>, with some of the <span class="math inline">\(d\)</span> components of <span class="math inline">\({{\boldsymbol{Y}}}_t\)</span> possibly latent. To do this efficiently, <strong><code>msde</code></strong> requires on-the-fly <strong>C++</strong> compiling of user-specified models. Instructions for setting up <strong>R</strong> to compile <strong>C++</strong> code are provided in the <a href="#install">Installation</a> section.</p>
</div>
<div id="creating-an-sde.model-object" class="section level2">
<h2>Creating an <code>sde.model</code> object</h2>
<p>The SDE model used throughout this vignette is the so-called Lotka-Volterra predator-prey model. Let <span class="math inline">\(H_t\)</span> and <span class="math inline">\(L_t\)</span> denote the number of Hare and Lynx at time <span class="math inline">\(t\)</span> coexisting in a given habitat. The Lotka-Volterra SDE describing the interactions between these two animal populations is given by <span class="citation">(Golightly and Wilkinson <a href="#ref-golightly-wilkinson10">2010</a>)</span>: <span class="math display">\[
\begin{bmatrix} \mathrm{d} H_t \\ \mathrm{d} L_t \end{bmatrix} = \begin{bmatrix} {\alpha}H_t - {\beta}H_tL_t \\ {\beta}H_tL_t - {\gamma}L_t \end{bmatrix}\, \mathrm{d} t + \begin{bmatrix} {\alpha}H_t + {\beta}H_tL_t &amp; -{\beta}H_tL_t \\ -{\beta}H_tL_t &amp; {\beta}H_tL_t + {\gamma}L_t\end{bmatrix}^{1/2} \begin{bmatrix} \mathrm{d} B_{1t} \\ \mathrm{d} B_{2t} \end{bmatrix}.
\]</span> Thus we have <span class="math inline">\(d = 2\)</span>, <span class="math inline">\({{\boldsymbol{Y}}}_t = (H_t, L_t)\)</span>, and <span class="math inline">\({{\boldsymbol{\theta}}}= ({\alpha}, {\beta}, {\gamma})\)</span>.</p>
<div id="the-sdemodel-class-definition" class="section level3">
<h3>The <code>sdeModel</code> class definition</h3>
<p>In order to build this model in <strong>C++</strong>, we create a header file <code>lotvolModel.h</code> containing the class definition for an <code>sdeModel</code> object. The basic structure of this class is given below:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// sde model object</span>
<span class="kw">class</span> sdeModel {
 <span class="kw">public</span>:
  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> nParams = <span class="dv">3</span>; <span class="co">// number of model parameters</span>
  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> nDims = <span class="dv">2</span>; <span class="co">// number of sde dimensions</span>
  <span class="at">static</span> <span class="at">const</span> <span class="dt">bool</span> sdDiff = <span class="kw">false</span>; <span class="co">// whether diffusion function is on sd or var scale</span>
  <span class="at">static</span> <span class="at">const</span> <span class="dt">bool</span> diagDiff = <span class="kw">false</span>; <span class="co">// whether diffusion function is diagonal</span>
  <span class="dt">void</span> sdeDr(<span class="dt">double</span> *dr, <span class="dt">double</span> *x, <span class="dt">double</span> *theta); <span class="co">// drift function</span>
  <span class="dt">void</span> sdeDf(<span class="dt">double</span> *df, <span class="dt">double</span> *x, <span class="dt">double</span> *theta); <span class="co">// diffusion function</span>
  <span class="dt">bool</span> isValidParams(<span class="dt">double</span> *theta); <span class="co">// parameter validator</span>
  <span class="dt">bool</span> isValidData(<span class="dt">double</span> *x, <span class="dt">double</span> *theta); <span class="co">// data validator</span>
};</code></pre></div>
<p>The meaning of each class member is as follows:</p>
<ul>
<li><code>nParams</code>: The number of model parameters. For the Lotka-Volterra model we have <span class="math inline">\({{\boldsymbol{\theta}}}= ({\alpha}, {\beta}, {\gamma})\)</span>, such that <code>nParams = 3</code>.</li>
<li><code>nDims</code>: The number of dimensions in the multivariate SDE. In this case we have <span class="math inline">\({{\boldsymbol{Y}}}_t = (H_t, L_t)\)</span>, such that <code>nDims = 2</code>.</li>
<li><p><code>sdeDr</code>: The SDE drift function. In <strong>R</strong>, this function would be implemented as</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sde.drift &lt;-<span class="st"> </span>function(x, theta) {
  dr &lt;-<span class="st"> </span><span class="kw">c</span>(theta[<span class="dv">1</span>]*x[<span class="dv">1</span>] -<span class="st"> </span>theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]*x[<span class="dv">2</span>], <span class="co"># alpha * H - beta * H*L</span>
      theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]*x[<span class="dv">2</span>] -<span class="st"> </span>theta[<span class="dv">3</span>]*x[<span class="dv">2</span>]) <span class="co"># beta * H*L - gamma * L</span>
  dr
}</code></pre></div>
<p>In <strong>C++</strong> the same thing is accomplished with</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> sdeDr(<span class="dt">double</span> *dr, <span class="dt">double</span> *x, <span class="dt">double</span> *theta) {
  dr[<span class="dv">0</span>] = theta[<span class="dv">0</span>]*x[<span class="dv">0</span>] - theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>]; <span class="co">// alpha * H - beta * H * L</span>
  dr[<span class="dv">1</span>] = theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>] - theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]; <span class="co">// beta * H * L - gamma * L</span>
  <span class="cf">return</span>;
}</code></pre></div></li>
<li><p><code>sdeDf</code>: The SDE diffusion function. This can be specified on the standard deviation scale, or on the variance scale as above. In this case, an <strong>R</strong> implementation would be</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sde.diff &lt;-<span class="st"> </span>function(x, theta) {
  df &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, <span class="dv">2</span>, <span class="dv">2</span>)
  df[<span class="dv">1</span>,<span class="dv">1</span>] &lt;-<span class="st"> </span>theta[<span class="dv">1</span>]*x[<span class="dv">1</span>] +<span class="st"> </span>theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]*x[<span class="dv">2</span>] <span class="co"># alpha * H + beta * H*L</span>
  df[<span class="dv">1</span>,<span class="dv">2</span>] &lt;-<span class="st"> </span>-theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]*x[<span class="dv">2</span>] <span class="co"># -beta * H*L</span>
  df[<span class="dv">2</span>,<span class="dv">1</span>] &lt;-<span class="st"> </span>df[<span class="dv">1</span>,<span class="dv">2</span>] <span class="co"># -beta * H*L</span>
  df[<span class="dv">2</span>,<span class="dv">2</span>] &lt;-<span class="st"> </span>theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]*x[<span class="dv">2</span>] +<span class="st"> </span>theta[<span class="dv">3</span>]*x[<span class="dv">2</span>] <span class="co"># beta * H*L + gamma * L</span>
  df
}</code></pre></div>
<p>In <strong>C++</strong> the specification is slightly different. First we set <code>sdDiff = false</code> in order to tell <strong><code>msde</code></strong> to use the variance scale. Next, the diffusion function is coded as</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> sdeDf(<span class="dt">double</span> *df, <span class="dt">double</span> *x, <span class="dt">double</span> *theta) {
  df[<span class="dv">0</span>] = theta[<span class="dv">0</span>]*x[<span class="dv">0</span>] + theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>]; <span class="co">// matrix element (1,1)</span>
  df[<span class="dv">2</span>] = -theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>]; <span class="co">// element (1,2)</span>
  df[<span class="dv">3</span>] = theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>] + theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]; <span class="co">// element (2,2)</span>
  <span class="cf">return</span>;
}</code></pre></div>
<p>Thus there are two major differences with the <strong>R</strong> version. The first is that the <code>df</code> matrix is stored as a vector (or “array” in <strong>C++</strong>). Its elements are stored in column-major order, i.e., by stacking the columns one after the other into one long vector. The second difference is that <strong><code>msde</code></strong> only uses the <em>upper triangular</em> portion of the (symmetric) matrix <span class="math inline">\({{\boldsymbol{\Sigma}}}_{{{\boldsymbol{\theta}}}}({{\boldsymbol{y}}})\)</span>. The elements below the diagonal can be set to any value or not set at all without affecting the computations.</p>
<p><strong><code>msde</code></strong> internally computes the Cholesky decomposition of the diffusion function when it is specified on the variance scale. For small problems such as this one, it is more efficient to specify the Cholesky decomposition directly, i.e., specify the diffusion on the standard deviation scale. In this case, the Cholesky decomposition of the diffusion function is <span class="math display">\[
\begin{bmatrix} {\alpha}H_t + {\beta}H_tL_t &amp; -{\beta}H_tL_t \\ -{\beta}H_tL_t &amp; {\beta}H_tL_t + {\gamma}L_t\end{bmatrix}^{1/2} = \begin{bmatrix} \sqrt{{\alpha}H_t + {\beta}H_tL_t} &amp; -\frac{{\beta}H_tL_t}{\sqrt{{\alpha}H_t + {\beta}H_tL_t}} \\ 0 &amp; \sqrt{{\beta}H_tL_t + {\gamma}L_t - \frac{({\beta}H_tL_t)^2}{{\alpha}H_t + {\beta}H_tL_t}} \end{bmatrix},
\]</span> which is passed to <strong><code>msde</code></strong> by setting <code>sdDiff = true</code> and</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> sdeDf(<span class="dt">double</span> *df, <span class="dt">double</span> *x, <span class="dt">double</span> *theta) {
  <span class="dt">double</span> bHL = theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>]; <span class="co">// beta * H*L</span>
  df[<span class="dv">0</span>] = sqrt(theta[<span class="dv">0</span>]*x[<span class="dv">0</span>] + bHL); <span class="co">// sqrt(alpha * H + bHL)</span>
  df[<span class="dv">2</span>] = -bHL/df[<span class="dv">0</span>];
  df[<span class="dv">3</span>] = sqrt(bHL + theta[<span class="dv">2</span>]*x[<span class="dv">1</span>] - df[<span class="dv">2</span>]*df[<span class="dv">2</span>]);
  <span class="cf">return</span>;
}</code></pre></div></li>
<li><p><code>diagDiff</code>: A logical specifying whether or not the diffusion matrix <span class="math inline">\({{\boldsymbol{\Sigma}}}_{{\boldsymbol{\theta}}}({{\boldsymbol{y}}})\)</span> is diagonal. For the Lotka-Volterra SDE model above, we set <code>diagDiff = false</code>. However, if the diffusion function were of the form <span class="math display">\[
{{\boldsymbol{\Sigma}}}_{{\boldsymbol{\theta}}}({{\boldsymbol{Y}}}_t) = \begin{bmatrix} {\alpha}H_t + {\beta}H_tL_t &amp; 0 \\ 0 &amp; {\beta}H_tL_t + {\gamma}L_t\end{bmatrix},
\]</span> then we would set <code>diagDiff = true</code>, <strong>and importantly</strong>, treat the <code>df</code> argument of <code>sdeDf</code> directly as the diagonal elements of the diffusion matrix. That is, the diffusion (on the variance scale) is encoded as</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> sdeDf(<span class="dt">double</span> *df, <span class="dt">double</span> *x, <span class="dt">double</span> *theta) {
  <span class="dt">double</span> bHL = theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>]; <span class="co">// beta * H*L</span>
  df[<span class="dv">0</span>] = theta[<span class="dv">0</span>]*x[<span class="dv">0</span>] + bHL; <span class="co">// alpha * H + bHL</span>
  <span class="co">// note the assignment to df[1] and not df[3]</span>
  df[<span class="dv">1</span>] = bHL + theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]; <span class="co">// bHL + gamma * L</span>
  <span class="cf">return</span>;
}</code></pre></div></li>
<li><p><code>isValidParams</code>: A logical used to specify the parameter support. In this case we have <span class="math inline">\({\alpha}, {\beta}, {\gamma}&gt; 0\)</span>, such that</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> isValidParams(<span class="dt">double</span> *theta) {
  <span class="dt">bool</span> val = theta[<span class="dv">0</span>] &gt; <span class="fl">0.0</span>;
  val = val &amp;&amp; theta[<span class="dv">1</span>] &gt; <span class="fl">0.0</span>;
  val = val &amp;&amp; theta[<span class="dv">2</span>] &gt; <span class="fl">0.0</span>;
  <span class="cf">return</span> val;
}</code></pre></div></li>
<li><p><code>isValidData</code>: A logical used to specify the SDE support, which can be parameter-dependent. In this case we simply have <span class="math inline">\(H_t, L_t &gt; 0\)</span>, such that</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> isValidData(<span class="dt">double</span> *x, <span class="dt">double</span> *theta) {
  <span class="cf">return</span> (x[<span class="dv">0</span>] &gt; <span class="fl">0.0</span>) &amp;&amp; (x[<span class="dv">1</span>] &gt; <span class="fl">0.0</span>);
}</code></pre></div></li>
</ul>
<p>Thus the whole file <code>lotvolModel.h</code> is given below:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifndef sdeModel_h</span>
<span class="pp">#define sdeModel_h 1</span>

<span class="co">// Lotka-Volterra Predator-Prey model</span>

<span class="co">// class definition</span>
<span class="kw">class</span> sdeModel {
 <span class="kw">public</span>:
  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> nParams = <span class="dv">3</span>; <span class="co">// number of model parameters</span>
  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> nDims = <span class="dv">2</span>; <span class="co">// number of sde dimensions</span>
  <span class="at">static</span> <span class="at">const</span> <span class="dt">bool</span> diagDiff = <span class="kw">false</span>; <span class="co">// whether diffusion function is diagonal</span>
  <span class="at">static</span> <span class="at">const</span> <span class="dt">bool</span> sdDiff = <span class="kw">true</span>; <span class="co">// whether diffusion is on sd or var scale</span>
  <span class="dt">void</span> sdeDr(<span class="dt">double</span> *dr, <span class="dt">double</span> *x, <span class="dt">double</span> *theta); <span class="co">// drift function</span>
  <span class="dt">void</span> sdeDf(<span class="dt">double</span> *df, <span class="dt">double</span> *x, <span class="dt">double</span> *theta); <span class="co">// diffusion function</span>
  <span class="dt">bool</span> isValidParams(<span class="dt">double</span> *theta); <span class="co">// parameter validator</span>
  <span class="dt">bool</span> isValidData(<span class="dt">double</span> *x, <span class="dt">double</span> *theta); <span class="co">// data validator</span>
};

<span class="co">// drift function</span>
<span class="kw">inline</span> <span class="dt">void</span> sdeModel::sdeDr(<span class="dt">double</span> *dr, <span class="dt">double</span> *x, <span class="dt">double</span> *theta) {
  dr[<span class="dv">0</span>] = theta[<span class="dv">0</span>]*x[<span class="dv">0</span>] - theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>]; <span class="co">// alpha * H - beta * H*L</span>
  dr[<span class="dv">1</span>] = theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>] - theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]; <span class="co">// beta * H*L - gamma * L</span>
  <span class="cf">return</span>;
}

<span class="co">// diffusion function (sd scale)</span>
<span class="kw">inline</span> <span class="dt">void</span> sdeModel::sdeDf(<span class="dt">double</span> *df, <span class="dt">double</span> *x, <span class="dt">double</span> *theta) {
  <span class="dt">double</span> bHL = theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>]; <span class="co">// beta * H*L</span>
  df[<span class="dv">0</span>] = sqrt(theta[<span class="dv">0</span>]*x[<span class="dv">0</span>] + bHL); <span class="co">// sqrt(alpha * H + bHL)</span>
  df[<span class="dv">2</span>] = -bHL/df[<span class="dv">0</span>];
  df[<span class="dv">3</span>] = sqrt(bHL + theta[<span class="dv">2</span>]*x[<span class="dv">1</span>] - df[<span class="dv">2</span>]*df[<span class="dv">2</span>]);
  <span class="cf">return</span>;
}

<span class="co">// parameter validator</span>
<span class="kw">inline</span> <span class="dt">bool</span> sdeModel::isValidParams(<span class="dt">double</span> *theta) {
  <span class="dt">bool</span> val = theta[<span class="dv">0</span>] &gt; <span class="fl">0.0</span>;
  val = val &amp;&amp; theta[<span class="dv">1</span>] &gt; <span class="fl">0.0</span>;
  val = val &amp;&amp; theta[<span class="dv">2</span>] &gt; <span class="fl">0.0</span>;
  <span class="cf">return</span> val;
}

<span class="co">// data validator</span>
<span class="kw">inline</span> <span class="dt">bool</span> sdeModel::isValidData(<span class="dt">double</span> *x, <span class="dt">double</span> *theta) {
  <span class="cf">return</span> (x[<span class="dv">0</span>] &gt; <span class="fl">0.0</span>) &amp;&amp; (x[<span class="dv">1</span>] &gt; <span class="fl">0.0</span>);
}

<span class="pp">#endif</span></code></pre></div>
<p>The additions to the previous code sections are:</p>
<ol style="list-style-type: decimal">
<li>The header include guards (<code>#ifndef</code>/<code>#define</code>/<code>#endif</code>).</li>
<li>The <code>sdeModel::</code> identifier is prepended to the class member definitions when these are written outside of the class declaration itself.</li>
<li>The <code>inline</code> keyword before the class member definitions, both of which ensure that only one instance of these functions is passed to the <strong>C++</strong> compiler.</li>
</ol>
</div>
<div id="compiling-and-checking-the-sde.model-object" class="section level3">
<h3>Compiling and checking the <code>sde.model</code> object</h3>
<p>One the <code>sdeModel</code> class is created as the <strong>C++</strong> level, it is compiled in <strong>R</strong> using the following commands:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span>(msde)

<span class="co"># put lotvolModel.h in the working directory</span>
data.names &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;H&quot;</span>, <span class="st">&quot;L&quot;</span>)
param.names &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;alpha&quot;</span>, <span class="st">&quot;beta&quot;</span>, <span class="st">&quot;gamma&quot;</span>)
lvmod &lt;-<span class="st"> </span><span class="kw">sde.make.model</span>(<span class="dt">ModelFile =</span> <span class="st">&quot;lotvolModel.h&quot;</span>,
                        <span class="dt">data.names =</span> data.names,
                        <span class="dt">param.names =</span> param.names)</code></pre></div>
<p>Before using the model for inference, it is useful to make sure that the <strong>C++</strong> entrypoints are error-free. To facilitate this, <strong><code>msde</code></strong> provides <strong>R</strong> wrappers to the internal <strong>C++</strong> drift, diffusion, and validator functions, which can then be checked against <strong>R</strong> versions as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># helper functions</span>

<span class="co"># random matrix of size nreps x length(x) from vector x</span>
jit.vec &lt;-<span class="st"> </span>function(x, nreps) {
  <span class="kw">apply</span>(<span class="kw">t</span>(<span class="kw">replicate</span>(<span class="dt">n =</span> nreps, <span class="dt">expr =</span> x, <span class="dt">simplify =</span> <span class="st">&quot;matrix&quot;</span>)), <span class="dv">2</span>, jitter)
}
<span class="co"># maximum absolute and relative error between two arrays</span>
max.diff &lt;-<span class="st"> </span>function(x1, x2) {
  <span class="kw">c</span>(<span class="dt">abs =</span> <span class="kw">max</span>(<span class="kw">abs</span>(x1-x2)), <span class="dt">rel =</span> <span class="kw">max</span>(<span class="kw">abs</span>(x1-x2)/<span class="kw">max</span>(<span class="kw">abs</span>(x1), <span class="fl">1e-8</span>)))
}

<span class="co"># R sde functions</span>

<span class="co"># drift and diffusion</span>
lv.drift &lt;-<span class="st"> </span>function(x, theta) {
  dr &lt;-<span class="st"> </span><span class="kw">c</span>(theta[<span class="dv">1</span>]*x[<span class="dv">1</span>] -<span class="st"> </span>theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]*x[<span class="dv">2</span>], <span class="co"># alpha * H - beta * H*L</span>
          theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]*x[<span class="dv">2</span>] -<span class="st"> </span>theta[<span class="dv">3</span>]*x[<span class="dv">2</span>]) <span class="co"># beta * H*L - gamma * L</span>
  dr
}
lv.diff &lt;-<span class="st"> </span>function(x, theta) {
  df &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, <span class="dv">2</span>, <span class="dv">2</span>)
  df[<span class="dv">1</span>,<span class="dv">1</span>] &lt;-<span class="st"> </span>theta[<span class="dv">1</span>]*x[<span class="dv">1</span>] +<span class="st"> </span>theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]*x[<span class="dv">2</span>] <span class="co"># alpha * H + beta * H*L</span>
  df[<span class="dv">1</span>,<span class="dv">2</span>] &lt;-<span class="st"> </span>-theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]*x[<span class="dv">2</span>] <span class="co"># -beta * H*L</span>
  df[<span class="dv">2</span>,<span class="dv">1</span>] &lt;-<span class="st"> </span>df[<span class="dv">1</span>,<span class="dv">2</span>] <span class="co"># -beta * H*L</span>
  df[<span class="dv">2</span>,<span class="dv">2</span>] &lt;-<span class="st"> </span>theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]*x[<span class="dv">2</span>] +<span class="st"> </span>theta[<span class="dv">3</span>]*x[<span class="dv">2</span>] <span class="co"># beta * H*L + gamma * L</span>
  <span class="kw">chol</span>(df) <span class="co"># always use sd scale in R</span>
}

<span class="co"># validators</span>
lv.valid.data &lt;-<span class="st"> </span>function(x, theta) <span class="kw">all</span>(x &gt;<span class="st"> </span><span class="dv">0</span>)
lv.valid.params &lt;-<span class="st"> </span>function(theta) <span class="kw">all</span>(theta &gt;<span class="st"> </span><span class="dv">0</span>)

<span class="co"># generate some test values</span>
nreps &lt;-<span class="st"> </span><span class="dv">12</span>
x0 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">H =</span> <span class="dv">71</span>, <span class="dt">L =</span> <span class="dv">79</span>)
theta0 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">alpha =</span> .<span class="dv">5</span>, <span class="dt">beta =</span> .<span class="dv">0025</span>, <span class="dt">gamma =</span> .<span class="dv">3</span>)
X &lt;-<span class="st"> </span><span class="kw">jit.vec</span>(x0, nreps)
Theta &lt;-<span class="st"> </span><span class="kw">jit.vec</span>(theta0, nreps)

<span class="co"># drift and diffusion check</span>

<span class="co"># R versions</span>
dr.R &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, nreps, lvmod$ndims) <span class="co"># drift</span>
df.R &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, nreps, lvmod$ndims^<span class="dv">2</span>) <span class="co"># diffusion</span>
for(ii in <span class="dv">1</span>:nreps) {
  dr.R[ii,] &lt;-<span class="st"> </span><span class="kw">lv.drift</span>(<span class="dt">x =</span> X[ii,], <span class="dt">theta =</span> Theta[ii,])
  <span class="co"># flattens diffusion matrix into a row</span>
  df.R[ii,] &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">lv.diff</span>(<span class="dt">x =</span> X[ii,], <span class="dt">theta =</span> Theta[ii,]))
}

<span class="co"># C++ versions</span>
dr.cpp &lt;-<span class="st"> </span><span class="kw">sde.drift</span>(<span class="dt">model =</span> lvmod, <span class="dt">x =</span> X, <span class="dt">theta =</span> Theta)
df.cpp &lt;-<span class="st"> </span><span class="kw">sde.diff</span>(<span class="dt">model =</span> lvmod, <span class="dt">x =</span> X, <span class="dt">theta =</span> Theta)

<span class="co"># compare</span>
<span class="kw">max.diff</span>(dr.R, dr.cpp)</code></pre></div>
<pre><code>## abs rel 
##   0   0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">max.diff</span>(df.R, df.cpp)</code></pre></div>
<pre><code>## abs rel 
##   0   0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># validator check</span>

<span class="co"># generate invalid data and parameters</span>
X.bad &lt;-<span class="st"> </span>X
X.bad[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>),<span class="dv">1</span>] &lt;-<span class="st"> </span>-X.bad[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>),<span class="dv">1</span>]
Theta.bad &lt;-<span class="st"> </span>Theta
Theta.bad[<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>),<span class="dv">3</span>] &lt;-<span class="st"> </span>-Theta.bad[<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>),<span class="dv">3</span>]

<span class="co"># R versions</span>
x.R &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, nreps)
theta.R &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, nreps)
for(ii in <span class="dv">1</span>:nreps) {
  x.R[ii] &lt;-<span class="st"> </span><span class="kw">lv.valid.data</span>(<span class="dt">x =</span> X.bad[ii,], <span class="dt">theta =</span> Theta.bad[ii,])
  theta.R[ii] &lt;-<span class="st"> </span><span class="kw">lv.valid.params</span>(<span class="dt">theta =</span> Theta.bad[ii,])
}

<span class="co"># C++ versions</span>
x.cpp &lt;-<span class="st"> </span><span class="kw">sde.valid.data</span>(<span class="dt">model =</span> lvmod, <span class="dt">x =</span> X.bad, <span class="dt">theta =</span> Theta.bad)
theta.cpp &lt;-<span class="st"> </span><span class="kw">sde.valid.params</span>(<span class="dt">model =</span> lvmod, <span class="dt">theta =</span> Theta.bad)

<span class="co"># compare</span>
<span class="kw">c</span>(<span class="dt">x =</span> <span class="kw">all</span>(x.R ==<span class="st"> </span>x.cpp), <span class="dt">theta =</span> <span class="kw">all</span>(theta.R ==<span class="st"> </span>theta.cpp))</code></pre></div>
<pre><code>##     x theta 
##  TRUE  TRUE</code></pre>
</div>
</div>
<div id="simulating-trajectories-from-the-lotka-volterra-model" class="section level2">
<h2>Simulating trajectories from the Lotka-Volterra model</h2>
<p>The basis for both simulation and inference with SDEs is the Euler-Maruyama approximation <span class="citation">(Maruyama <a href="#ref-maruyama55">1955</a>)</span>, which states that over a small time interval <span class="math inline">\({\Delta t}\)</span>, the (intractable) transition density of the SDE can be approximated by <span class="math display">\[
{{\boldsymbol{Y}}}_{t+{\Delta t}} \mid {{\boldsymbol{Y}}}_t \approx {\mathcal{N}}\Big({{\boldsymbol{Y}}}_t + {{\boldsymbol{\Lambda}}}_{{\boldsymbol{\theta}}}({{\boldsymbol{Y}}}_t){\Delta t}, {{\boldsymbol{\Sigma}}}_{{\boldsymbol{\theta}}}({{\boldsymbol{Y}}}_t){\Delta t}\Big),
\]</span> with convergence to the true SDE dynamics as <span class="math inline">\({\Delta t}\to 0\)</span>.</p>
<p>In order to simulate data from the Lotka-Volterra SDE model, we use the function <code>sde.sim</code>. Here we’ll generate <span class="math inline">\(N = 50\)</span> observations of the process with initial values <span class="math inline">\({{\boldsymbol{Y}}}_0 = (71, 79)\)</span>, and parameter values <span class="math inline">\({{\boldsymbol{\theta}}}= (.5, .0025,.3)\)</span>, with time between observations of <span class="math inline">\({\Delta t}= 1\)</span> year. The <code>dt.sim</code> argument to <code>sde.sim</code> specifies the internal observation time used by the Euler-Maruyama approximation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># simulation parameters</span>
theta0 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">alpha =</span> .<span class="dv">5</span>, <span class="dt">beta =</span> .<span class="dv">0025</span>, <span class="dt">gamma =</span> .<span class="dv">3</span>) <span class="co"># true parameter values</span>
x0 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">H =</span> <span class="dv">71</span>, <span class="dt">L =</span> <span class="dv">79</span>) <span class="co"># initial SDE values</span>
N &lt;-<span class="st"> </span><span class="dv">50</span> <span class="co"># number of observations</span>
dT &lt;-<span class="st"> </span><span class="dv">1</span> <span class="co"># time between observations (years)</span>

<span class="co"># simulate data</span>
lvsim &lt;-<span class="st"> </span><span class="kw">sde.sim</span>(<span class="dt">model =</span> lvmod, <span class="dt">x0 =</span> x0, <span class="dt">theta =</span> theta0,
                 <span class="dt">nobs =</span> N<span class="dv">-1</span>, <span class="co"># N-1 steps forward</span>
                 <span class="dt">dt =</span> dT,
                 <span class="dt">dt.sim =</span> dT/<span class="dv">100</span>) <span class="co"># internal observation time</span></code></pre></div>
<pre><code>## Number of normal draws required: 4900</code></pre>
<pre><code>## Running simulation...</code></pre>
<pre><code>## Execution time: 0 seconds.</code></pre>
<pre><code>## Bad Draws = 0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># plot data</span>
Xobs &lt;-<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(x0), lvsim$data) <span class="co"># include first observation</span>
tseq &lt;-<span class="st"> </span>(<span class="dv">1</span>:N<span class="dv">-1</span>)*dT <span class="co"># observation times</span>
clrs &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;black&quot;</span>, <span class="st">&quot;red&quot;</span>)
<span class="kw">par</span>(<span class="dt">mar =</span> <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">0</span>)+.<span class="dv">1</span>)
<span class="kw">plot</span>(<span class="dt">x =</span> <span class="dv">0</span>, <span class="dt">type =</span> <span class="st">&quot;n&quot;</span>, <span class="dt">xlim =</span> <span class="kw">range</span>(tseq), <span class="dt">ylim =</span> <span class="kw">range</span>(Xobs),
     <span class="dt">xlab =</span> <span class="st">&quot;Time (years)&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;Population&quot;</span>)
<span class="kw">lines</span>(tseq, Xobs[,<span class="st">&quot;H&quot;</span>], <span class="dt">type =</span> <span class="st">&quot;o&quot;</span>, <span class="dt">pch =</span> <span class="dv">16</span>, <span class="dt">col =</span> clrs[<span class="dv">1</span>])
<span class="kw">lines</span>(tseq, Xobs[,<span class="st">&quot;L&quot;</span>], <span class="dt">type =</span> <span class="st">&quot;o&quot;</span>, <span class="dt">pch =</span> <span class="dv">16</span>, <span class="dt">col =</span> clrs[<span class="dv">2</span>])
<span class="kw">legend</span>(<span class="st">&quot;topleft&quot;</span>, <span class="dt">legend =</span> <span class="kw">c</span>(<span class="st">&quot;Hare&quot;</span>, <span class="st">&quot;Lynx&quot;</span>), <span class="dt">fill =</span> clrs)</code></pre></div>
<p><img src="data:image/png;base64,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Hnjggw8+OHz4sHz7eejRfD7fH3/8UVlZabfbNRrNb7/99k/rSR86dOj222+/ePGiJElLly6tqqrq7+8PBALy0d9//z0uLi4hIWEELgYADCfuQAOAOkmS9Oyzz65Zs+bcuXMZGRnNzc2bN292uVyXL7SclpbW1tYW3bJ48eJVq1aFw+FIgB5iNKvVqtVq16xZ89BDDwWDwW3btt10001NTU0tLS12uz16WLvd/sMPPyxfvry0tLS/v3///v1JSUmR29XfffddWloa60ADuPYRoAFAtVwul16vr6qqev3111NTU9966621a9de3u2+++6rrq4Oh8OR8Prggw8KIbKysiJfLhxitKlTp1ZXV7/wwgsOh8Nut2/ZskWr1ZaVlTU0NAwK0Far9eDBg5WVlWvXro2Njc3KympoaJg0aZJ89PTp0zk5OSNzJQBgOPEmQgC40fX09KSkpHz++ec2m01uCYVCkyZNcjqdzz///OjMob+/f/LkyTU1NQsWLBidMwLAFeMZaAC40SUkJKxYscLr9UZaTpw4EXl/yug4efJkYmIid6ABXBe4Aw0AEIFAYNGiRa2trZcuXdq3b98777yTkZEhv5NldJSWlubm5paVlY3aGQHgihGgAQBCCLFx40aTyVRQUJCZmWm32/fu3WsymUbn1H6/v7y8/OTJk+PG8XdRANcBAjQAAACgAJ/1AQAAAAX+Cw1EFTJrGQqcAAAAAElFTkSuQmCC" width="90%" /></p>
</div>
<div id="inference-for-multivariate-sde-models" class="section level2">
<h2>Inference for multivariate SDE models</h2>
<p>Parameter inference is conducted used a well-known data augmentation scheme due to <span class="citation">Pedersen (<a href="#ref-pedersen95">1995</a>)</span>. Assume that, as above, the SDE observations are evenly spaced with interobservation time <span class="math inline">\({\Delta t}\)</span>. For any integer <span class="math inline">\(m &gt; 0\)</span>, let <span class="math inline">\({{\boldsymbol{Y}}}_{(m)} = ({{{\boldsymbol{Y}}}_{m,0},\ldots,{{\boldsymbol{Y}}}_{m,Nm}})\)</span> denote the value of the SDE at equally spaced intervals of <span class="math inline">\({\Delta t}_m = {\Delta t}/m\)</span>. Thus, <span class="math inline">\({{\boldsymbol{Y}}}_{(1)} = {{\boldsymbol{Y}}}\)</span> corresponds to the observed data, and for <span class="math inline">\(m &gt; 1\)</span>, we have <span class="math inline">\({{\boldsymbol{Y}}}_{m,nm} = {{\boldsymbol{Y}}}_n\)</span>. Thus we shall refer to the “missing data” as <span class="math inline">\({{{\boldsymbol{Y}}}_{\mathrm{miss}}}= {{\boldsymbol{Y}}}_{(m)} \setminus {{\boldsymbol{Y}}}\)</span>. The Euler-Maruyama approximation to the complete likelihood is <span class="math display">\[
\mathcal L({{\boldsymbol{\theta}}}\mid {{\boldsymbol{Y}}}_{(m)}) = \prod_{n=0}^{Nm-1} \varphi\Big({{\boldsymbol{Y}}}_{m,n+1} \mid {{\boldsymbol{Y}}}_{m,n} + {{\boldsymbol{\Lambda}}}_{{\boldsymbol{\theta}}}({{\boldsymbol{Y}}}_{m,n}){\Delta t}_m, {{\boldsymbol{\Sigma}}}_{{\boldsymbol{\theta}}}({{\boldsymbol{Y}}}_{m,n}{\Delta t})\Big),
\]</span> where <span class="math inline">\(\varphi({{\boldsymbol{y}}}\mid \mathbf \mu, \mathbf \Sigma)\)</span> is the PDF of <span class="math inline">\({{\boldsymbol{y}}}\sim {\mathcal{N}}(\mathbf \mu, \mathbf \Sigma)\)</span>. The Bayesian data augmentation scheme then consists of chosing a prior <span class="math inline">\(\pi({{\boldsymbol{\theta}}})\)</span> and sampling from the posterior distribution <span class="math display">\[
p_m({{\boldsymbol{\theta}}}\mid {{\boldsymbol{Y}}}) = \int \mathcal L({{\boldsymbol{\theta}}}\mid {{\boldsymbol{Y}}}_{(m)}) \times \pi({{\boldsymbol{\theta}}}) \, {\mathrm{d}}{{{\boldsymbol{Y}}}_{\mathrm{miss}}}.
\]</span> As <span class="math inline">\(m \to \infty\)</span> this approximate posterior converges to the true SDE posterior <span class="math inline">\(p({{\boldsymbol{\theta}}}\mid {{\boldsymbol{Y}}})\)</span>.</p>
<p>Posterior sampling from the Euler-Maruyama posterior is accomplished with the function <code>sde.post</code>. In the following example we use <span class="math inline">\(m = 1\)</span>, i.e., there is no missing data. We’ll use a Lebesgue prior <span class="math inline">\(\pi({{\boldsymbol{\theta}}}) \propto 1\)</span>; more information on the <a href="#defprior">default</a> and <a href="#custprior">custom</a> prior specifications can be found in the following sections.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># initialize the posterior sampler</span>
init &lt;-<span class="st"> </span><span class="kw">sde.init</span>(<span class="dt">model =</span> lvmod, <span class="dt">x =</span> Xobs, <span class="dt">dt =</span> dT,
                 <span class="dt">m =</span> <span class="dv">1</span>, <span class="dt">theta =</span> <span class="kw">c</span>(.<span class="dv">1</span>, .<span class="dv">1</span>, .<span class="dv">1</span>))

nsamples &lt;-<span class="st"> </span><span class="fl">2e4</span>
burn &lt;-<span class="st"> </span><span class="fl">2e3</span>
lvpost &lt;-<span class="st"> </span><span class="kw">sde.post</span>(<span class="dt">model =</span> lvmod, <span class="dt">init =</span> init,
                   <span class="dt">hyper =</span> <span class="ot">NULL</span>, <span class="co">#prior specification</span>
                   <span class="dt">nsamples =</span> nsamples, <span class="dt">burn =</span> burn)</code></pre></div>
<pre><code>## Output size:</code></pre>
<pre><code>## params = 60000</code></pre>
<pre><code>## Running posterior sampler...</code></pre>
<pre><code>## Execution time: 0.8 seconds.</code></pre>
<pre><code>## alpha accept: 44.3%</code></pre>
<pre><code>## beta accept: 43.4%</code></pre>
<pre><code>## gamma accept: 44.2%</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># posterior histograms</span>
tnames &lt;-<span class="st"> </span><span class="kw">expression</span>(alpha, beta, gamma)
<span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>))
for(ii in <span class="dv">1</span>:lvmod$nparams) {
  <span class="kw">hist</span>(lvpost$params[,ii], <span class="dt">breaks =</span> <span class="dv">25</span>, <span class="dt">freq =</span> <span class="ot">FALSE</span>,
       <span class="dt">xlab =</span> tnames[ii],
       <span class="dt">main =</span> <span class="kw">parse</span>(<span class="dt">text =</span> <span class="kw">paste0</span>(<span class="st">&quot;p[1](&quot;</span>, tnames[ii], <span class="st">&quot;*</span><span class="ch">\&quot;</span><span class="st"> | </span><span class="ch">\&quot;</span><span class="st">*bold(Y))&quot;</span>)))
  <span class="co"># superimpose true parameter value</span>
  <span class="kw">abline</span>(<span class="dt">v =</span> theta0[ii], <span class="dt">lwd =</span> <span class="dv">4</span>, <span class="dt">lty =</span> <span class="dv">2</span>)
}</code></pre></div>
<p><img src="data:image/png;base64,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" width="90%" /></p>
<div id="missing-data-specification-with-sde.init" class="section level3">
<h3>Missing data specification with <code>sde.init</code></h3>
<p>In the example above there was no missing data, i.e., <span class="math inline">\(m = 1\)</span> and both components of the SDE are observed at each time <span class="math inline">\({t_{0},\ldots,t_{n}}\)</span>. In order to refine the Euler-Maruyama approximation, we simply pass a larger value of <span class="math inline">\(m\)</span> to <code>sde.init</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 3 missing data points between each observation, so dt_m = dt/4</span>
m &lt;-<span class="st"> </span><span class="dv">4</span>
init &lt;-<span class="st"> </span><span class="kw">sde.init</span>(<span class="dt">model =</span> lvmod, <span class="dt">x =</span> Xobs, <span class="dt">dt =</span> dT,
                 <span class="dt">m =</span> m, <span class="dt">theta =</span> <span class="kw">c</span>(.<span class="dv">1</span>, .<span class="dv">1</span>, .<span class="dv">1</span>))</code></pre></div>
<p>We can also assume that only the first <span class="math inline">\(q &lt; d\)</span> components of the SDE are observed, with the last <span class="math inline">\(d-q\)</span> being latent. In this case with <span class="math inline">\(q = 1\)</span>, the lynx population would be unobserved, and this is specified with the <code>nvar.obs</code> argument:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">init &lt;-<span class="st"> </span><span class="kw">sde.init</span>(<span class="dt">model =</span> lvmod, <span class="dt">x =</span> Xobs, <span class="dt">dt =</span> dT,
                 <span class="dt">nvar.obs =</span> <span class="dv">1</span>, <span class="co"># number of &quot;observed&quot; variables per timepoint</span>
                 <span class="dt">m =</span> m, <span class="dt">theta =</span> <span class="kw">c</span>(.<span class="dv">1</span>, .<span class="dv">1</span>, .<span class="dv">1</span>))</code></pre></div>
<p>Note that the initial data <code>x</code> must still be supplied as an <span class="math inline">\((N+1) \times d\)</span> matrix, with the missing values corresponding to initial values for the MCMC sampler.</p>
</div>
<div id="defprior" class="section level3">
<h3>Default prior specification</h3>
<p>Since <strong><code>msde</code></strong> allows for some of the <span class="math inline">\(q\)</span> components of <span class="math inline">\({{\boldsymbol{Y}}}_t\)</span> to be latent, a prior must be specified not only for <span class="math inline">\({{\boldsymbol{\theta}}}\)</span> but also for the latent variables in the initial observation <span class="math inline">\({{\boldsymbol{Y}}}_0\)</span>.</p>
<p>In the example above, we assumed a Lebesgue prior <span class="math inline">\(\pi({{\boldsymbol{\theta}}}, {{\boldsymbol{Y}}}_0) \propto 1\)</span>, with the restriction that <span class="math inline">\({{\boldsymbol{\theta}}}, {{\boldsymbol{Y}}}_0 &gt; 0\)</span> (as specified in the <code>sdeModel</code> class definition via the <code>isValidData</code> and <code>isValidParams</code> validators).</p>
<div id="default-prior" class="section level4">
<h4>Default prior</h4>
<p>The default prior in <strong><code>msde</code></strong> is a multivariate normal, for which the (fixed) hyper-parameters are supplied via the <code>hyper</code> argument to <code>sde.post</code>. The <code>hyper</code> argument can either be <code>NULL</code>, or a list with elements <code>mu</code> and <code>Sigma</code>. These consist of a named vector named matrix specifying the mean and variance of the named elements. Unnamed elements are given a Lebesgue prior. So for example, posterior inference for the dataset above with <span class="math inline">\(m = 1\)</span>, latent variable <span class="math inline">\(L\)</span>, and prior distribution <span class="math display">\[
L_0, \alpha, \gamma {\stackrel{\mathrm{iid}}{\sim}}{\mathcal{N}}(1, 1), \qquad \pi(H_0, \beta \mid H_0, \alpha, \gamma) \propto 1
\]</span> is obtained as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># prior specification</span>
pnames &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;L&quot;</span>, <span class="st">&quot;alpha&quot;</span>, <span class="st">&quot;gamma&quot;</span>)
hyper &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">mu =</span> <span class="kw">rep</span>(<span class="dv">1</span>, <span class="dv">3</span>), <span class="dt">Sigma =</span> <span class="kw">diag</span>(<span class="dv">3</span>))
<span class="kw">names</span>(hyper$mu) &lt;-<span class="st"> </span>pnames
<span class="kw">dimnames</span>(hyper$Sigma) &lt;-<span class="st"> </span><span class="kw">list</span>(pnames, pnames)

<span class="co"># initialize the posterior sampler</span>
init &lt;-<span class="st"> </span><span class="kw">sde.init</span>(<span class="dt">model =</span> lvmod, <span class="dt">x =</span> Xobs, <span class="dt">dt =</span> dT,
                 <span class="dt">m =</span> <span class="dv">1</span>, <span class="dt">nvar.obs =</span> <span class="dv">1</span>, <span class="co"># L is latent</span>
                 <span class="dt">theta =</span> <span class="kw">c</span>(.<span class="dv">1</span>, .<span class="dv">1</span>, .<span class="dv">1</span>))

nsamples &lt;-<span class="st"> </span><span class="fl">2e4</span>
burn &lt;-<span class="st"> </span><span class="fl">2e3</span>
lvpost &lt;-<span class="st"> </span><span class="kw">sde.post</span>(<span class="dt">model =</span> lvmod, <span class="dt">init =</span> init,
                   <span class="dt">hyper =</span> hyper, <span class="co">#prior specification</span>
                   <span class="dt">nsamples =</span> nsamples, <span class="dt">burn =</span> burn)</code></pre></div>
<pre><code>## Output size:</code></pre>
<pre><code>## params = 60000</code></pre>
<pre><code>## data = 2e+05</code></pre>
<pre><code>## Running posterior sampler...</code></pre>
<pre><code>## Execution time: 0.72 seconds.</code></pre>
<pre><code>## Bridge accept: min = 0.0545%, avg = 31.3%</code></pre>
<pre><code>## alpha accept: 44.2%</code></pre>
<pre><code>## beta accept: 43.1%</code></pre>
<pre><code>## gamma accept: 44%</code></pre>
<pre><code>## L0 accept: 44.4%</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># posterior histograms</span>
tnames &lt;-<span class="st"> </span><span class="kw">expression</span>(alpha, beta, gamma)
<span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>))
for(ii in <span class="dv">1</span>:lvmod$nparams) {
  <span class="kw">hist</span>(lvpost$params[,ii], <span class="dt">breaks =</span> <span class="dv">25</span>, <span class="dt">freq =</span> <span class="ot">FALSE</span>,
       <span class="dt">xlab =</span> tnames[ii],
       <span class="dt">main =</span> <span class="kw">parse</span>(<span class="dt">text =</span> <span class="kw">paste0</span>(<span class="st">&quot;p[1](&quot;</span>, tnames[ii], <span class="st">&quot;*</span><span class="ch">\&quot;</span><span class="st"> | </span><span class="ch">\&quot;</span><span class="st">*bold(Y))&quot;</span>)))
  <span class="co"># superimpose true parameter value</span>
  <span class="kw">abline</span>(<span class="dt">v =</span> theta0[ii], <span class="dt">lwd =</span> <span class="dv">4</span>, <span class="dt">lty =</span> <span class="dv">2</span>)
}</code></pre></div>
<p><img src="data:image/png;base64,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" width="90%" /></p>
</div>
</div>
</div>
<div id="custprior" class="section level2">
<h2>Custom prior specification</h2>
<p><strong><code>msde</code></strong> provides a two-stage mechanism for specifying user-defined priors. This is illustrated below with a simple log-normal prior on <span class="math inline">\({{\boldsymbol{\eta}}}= (\alpha, \gamma, \beta, L_0) = ({\eta_{1},\ldots,\eta_{4}})\)</span>, namely <span class="math display">\[
\pi({{\boldsymbol{\eta}}}) \iff \log(\eta_i) {\stackrel{\mathrm{iid}}{\sim}}{\mathcal{N}}(\mu_i, \sigma_i^2),
\]</span> where the hyperparameters are <span class="math inline">\({\boldsymbol{\mu}} = ({\mu_{1},\ldots,\mu_{4}})\)</span> and <span class="math inline">\({\boldsymbol{\sigma}} = ({\sigma_{1},\ldots,\sigma_{4}})\)</span>. Ultimately, the hyperparameters will be passed to <code>sde.post</code> as a two-element list, e.g.,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hyper &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">mu =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>), <span class="dt">sigma =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>))</code></pre></div>
<div id="the-sdeprior-class-definition" class="section level3">
<h3>The <code>sdePrior</code> class definition</h3>
<p>The first step of the prior specification is to define it at the <strong>C++</strong> level, through the <code>sdPrior</code> class. The class corresponding to the log-normal prior above is defined in the file <code>lotvolPrior.h</code> pasted below.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifndef sdePrior_h</span>
<span class="pp">#define sdePrior_h 1</span>

<span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span><span class="pp"> </span><span class="co">// contains R's dlnorm function</span>

<span class="co">// Prior for Lotka-Volterra Model</span>

<span class="kw">class</span> sdePrior {
 <span class="kw">private</span>:
  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> nHyper = <span class="dv">4</span>; <span class="co">// (alpha, beta, gamma, L)</span>
  <span class="dt">double</span> *mean, *sd; <span class="co">// log-normal mean and standard deviation vectors</span>
 <span class="kw">public</span>:
  <span class="dt">double</span> logPrior(<span class="dt">double</span> *theta, <span class="dt">double</span> *x); <span class="co">// log-prior function</span>
  sdePrior(<span class="dt">double</span> **phi, <span class="dt">int</span> nArgs, <span class="dt">int</span> *nEachArg); <span class="co">// constructor</span>
  ~sdePrior(); <span class="co">// destructor</span>
};

<span class="co">// constructor</span>
<span class="kw">inline</span> sdePrior::sdePrior(<span class="dt">double</span> **phi, <span class="dt">int</span> nArgs, <span class="dt">int</span> *nEachArg) {
  <span class="co">// allocate memory for hyperparameters</span>
  mean = <span class="kw">new</span> <span class="dt">double</span>[nHyper];
  sd = <span class="kw">new</span> <span class="dt">double</span>[nHyper];
  <span class="co">// hard-copy hyperparameters into Prior object</span>
  <span class="cf">for</span>(<span class="dt">int</span> ii=<span class="dv">0</span>; ii&lt;nHyper; ii++) {
    mean[ii] = phi[<span class="dv">0</span>][ii];
    sd[ii] = phi[<span class="dv">1</span>][ii];
  }
}

<span class="co">// destructor</span>
<span class="kw">inline</span> sdePrior::~sdePrior() {
  <span class="co">// deallocate memory to avoid memory leaks</span>
  <span class="kw">delete</span> [] mean;
  <span class="kw">delete</span> [] sd;
}

<span class="co">// log-prior function itself:</span>
<span class="co">// independent log-normal densities for (alpha,beta,gamma,L)</span>
<span class="kw">inline</span> <span class="dt">double</span> sdePrior::logPrior(<span class="dt">double</span> *theta, <span class="dt">double</span> *x) {
  <span class="dt">double</span> lpi = <span class="fl">0.0</span>;
  <span class="co">// alpha,beta,gamma</span>
  <span class="cf">for</span>(<span class="dt">int</span> ii=<span class="dv">0</span>; ii &lt; <span class="dv">3</span>; ii++) {
    lpi += R::dlnorm(theta[ii], mean[ii], sd[ii], <span class="dv">1</span>);
  }
  <span class="co">// L</span>
  lpi += R::dlnorm(x[<span class="dv">1</span>], mean[<span class="dv">3</span>], sd[<span class="dv">3</span>], <span class="dv">1</span>);
  <span class="cf">return</span> lpi;
}

<span class="pp">#endif</span></code></pre></div>
<p>The meaning of each class member is as follows:</p>
<ul>
<li><code>sdePrior</code>: The class constructor. This is how the <strong>C++</strong> code collects the hyperparameters from <strong>R</strong>. Its argument signature must be matched <em>exactly</em> and has the following meaning:
<ul>
<li><code>phi</code>: A double-pointers of type <code>double</code>. This is a simple mechanism to give the address of the elements of a list of numeric vectors, as the hyperparameters are defined on the <strong>R</strong> side. So with the example above, <span class="math inline">\(\sigma_2\)</span> is pointed to by <code>phi[1][1]</code>.</li>
<li><code>nArgs</code>: The number of elements in the hyperparameter vector, i.e., <code>length(hyper)</code>, which in this case is 2. In this case this number is known in advance, but for greater flexibility it is determined at runtime automatically in the <strong>C++</strong> code from the specific value of <code>hyper</code>.</li>
<li><code>nEachArg</code>: The length of each hyperparameter element, i.e., <code>sapply(hyper, length)</code>. Again this is determined automatically from the <strong>C++</strong> code. Note that for speed considerations, the contents of <code>phi</code> should be copied directly into the <code>sdePrior</code> object, held here in the private members <code>mean</code> and <code>sd</code>.</li>
</ul></li>
<li><code>~sdePrior</code>: The class destructor, which is needed to deallocate the dynamic memory to prevent memory leaks.</li>
<li><code>logPrior</code>: The log-prior function itself, of which the signature must be matched <em>exactly</em>. Its arguments correspond to <span class="math inline">\({{\boldsymbol{\theta}}}\)</span> and <span class="math inline">\({{\boldsymbol{Y}}}_0\)</span>. In this case, we use the <strong>C++</strong> version of <strong>R</strong>’s <code>dlnorm</code> function, which is accessible by including <code>Rcpp.h</code>.</li>
</ul>
</div>
<div id="formatting-the-r-input-to-the-c-code" class="section level3">
<h3>Formatting the <strong>R</strong> input to the <strong>C++</strong> code</h3>
<p><strong>C++</strong> is much less forgiving that <strong>R</strong> when it comes to accepting incorrect inputs. Thus, if a user accidently passed the hyperparameters to <code>sde.post</code> as e.g.,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bad.hyper &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">mean =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>))</code></pre></div>
<p>at best this would cause garbage MCMC output and at worst, the <strong>R</strong> session to terminate abruptly. For this reason <strong><code>msde</code></strong> provides an input-checking mechanism, which can also used to format the hyperparameters into the list-of-numeric-vectors input expected by the <strong>C++</strong> code. This is done by passing an appropriate input checking function to <code>sde.make.model</code> through the argument <code>hyper.check</code>. This argument accepts a function with the <em>exact</em> signature of the example below. In this example, <code>hyper</code> must be a list with elements <code>mu</code> and <code>sigma</code>, which are either:</p>
<ol style="list-style-type: decimal">
<li>scalars, in which case each is replicated four times.</li>
<li>vectors of length four, in which case the order is determined by <span class="math inline">\({{\boldsymbol{\eta}}}= (\alpha, \beta, \gamma, L_0)\)</span>.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># must match argument signature _exactly_</span>
lvcheck &lt;-<span class="st"> </span>function(hyper, param.names, data.names) {
  if(<span class="kw">is.null</span>(<span class="kw">names</span>(hyper)) ||
<span class="st">     </span>!<span class="kw">identical</span>(<span class="kw">sort</span>(<span class="kw">names</span>(hyper)), <span class="kw">c</span>(<span class="st">&quot;mu&quot;</span>, <span class="st">&quot;sigma&quot;</span>))) {
    <span class="kw">stop</span>(<span class="st">&quot;hyper must be a list with elements mu and sigma.&quot;</span>)
  }
  mu &lt;-<span class="st"> </span>hyper$mu
  if(<span class="kw">length</span>(mu) ==<span class="st"> </span><span class="dv">1</span>) mu &lt;-<span class="st"> </span><span class="kw">rep</span>(mu, <span class="dv">4</span>)
  if(!<span class="kw">is.numeric</span>(mu) ||<span class="st"> </span><span class="kw">length</span>(mu) !=<span class="st"> </span><span class="dv">4</span>) {
    <span class="kw">stop</span>(<span class="st">&quot;mu must be a numeric scalar or vector of length four.&quot;</span>)
  }
  sig &lt;-<span class="st"> </span>hyper$sigma
  if(<span class="kw">length</span>(sig) ==<span class="st"> </span><span class="dv">1</span>) sig &lt;-<span class="st"> </span><span class="kw">rep</span>(sig, <span class="dv">4</span>)
  if(!<span class="kw">is.numeric</span>(sig) ||<span class="st"> </span><span class="kw">length</span>(sig) !=<span class="st"> </span><span class="dv">4</span> ||<span class="st"> </span>!<span class="kw">all</span>(sig &gt;<span class="st"> </span><span class="dv">0</span>)) {
    <span class="kw">stop</span>(<span class="st">&quot;sigma must be a positive scalar or vector of length four.&quot;</span>)
  }
  <span class="kw">list</span>(mu, sig)
}
<span class="co">#lvcheck &lt;- mvn.hyper.check</span></code></pre></div>
</div>
<div id="compiling-and-checking-the-prior" class="section level3">
<h3>Compiling and checking the prior</h3>
<p>Now we are ready to create the <code>sde.model</code> object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">data.names &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;H&quot;</span>, <span class="st">&quot;L&quot;</span>)
param.names &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;alpha&quot;</span>, <span class="st">&quot;beta&quot;</span>, <span class="st">&quot;gamma&quot;</span>)
lvmod2 &lt;-<span class="st"> </span><span class="kw">sde.make.model</span>(<span class="dt">ModelFile =</span> <span class="st">&quot;lotvolModel.h&quot;</span>,
                        <span class="dt">PriorFile =</span> <span class="st">&quot;lotvolPrior.h&quot;</span>, <span class="co"># prior specification</span>
                        <span class="dt">hyper.check =</span> lvcheck, <span class="co"># prior input checking</span>
                        <span class="dt">data.names =</span> data.names,
                        <span class="dt">param.names =</span> param.names)</code></pre></div>
<p>We can also test the <strong>C++</strong> implementation of the prior against one written in <strong>R</strong>, using the <strong><code>msde</code></strong> function <code>sde.prior</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># generate some test values</span>
nreta &lt;-<span class="st"> </span><span class="dv">12</span>
x0 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">H =</span> <span class="dv">71</span>, <span class="dt">L =</span> <span class="dv">79</span>)
theta0 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">alpha =</span> .<span class="dv">5</span>, <span class="dt">beta =</span> .<span class="dv">0025</span>, <span class="dt">gamma =</span> .<span class="dv">3</span>)
X &lt;-<span class="st"> </span><span class="kw">jit.vec</span>(x0, nreta)
Theta &lt;-<span class="st"> </span><span class="kw">jit.vec</span>(theta0, nreta)
Eta &lt;-<span class="st"> </span><span class="kw">cbind</span>(Theta, <span class="dt">L =</span> X[,<span class="st">&quot;L&quot;</span>])
nrphi &lt;-<span class="st"> </span><span class="dv">5</span>
Phi &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="dv">1</span>:nrphi, function(ii) <span class="kw">list</span>(<span class="dt">mu =</span> <span class="kw">rnorm</span>(<span class="dv">4</span>), <span class="dt">sigma =</span> <span class="kw">rexp</span>(<span class="dv">4</span>)))

<span class="co"># prior check</span>

<span class="co"># R version</span>
lpi.R &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, nreta, nrphi)
for(ii in <span class="dv">1</span>:nrphi) {
  lpi.R[,ii] &lt;-<span class="st"> </span><span class="kw">colSums</span>(<span class="kw">dlnorm</span>(<span class="dt">x =</span>  <span class="kw">t</span>(Eta),
                               <span class="dt">meanlog =</span> Phi[[ii]]$mu,
                               <span class="dt">sdlog =</span> Phi[[ii]]$sigma, <span class="dt">log =</span> <span class="ot">TRUE</span>))
}

<span class="co"># C++ version</span>
lpi.cpp &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, nreta, nrphi)
for(ii in <span class="dv">1</span>:nrphi) {
  lpi.cpp[,ii] &lt;-<span class="st"> </span><span class="kw">sde.prior</span>(<span class="dt">model =</span> lvmod2, <span class="dt">theta =</span> Theta, <span class="dt">x =</span> X,
                            <span class="dt">hyper =</span> Phi[[ii]])
}

<span class="co"># compare</span>
<span class="kw">max.diff</span>(lpi.R, lpi.cpp)</code></pre></div>
<pre><code>##          abs          rel 
## 1.455192e-11 1.405963e-16</code></pre>
</div>
</div>
<div id="install" class="section level2">
<h2>Installation</h2>
<p>The <strong><code>msde</code></strong> package requires on-the-fly <strong>C++</strong> compiling of user-specified models which is handled through the <strong>R</strong> package <strong><code>Rcpp</code></strong> <span class="citation">(Eddelbuettel and François <a href="#ref-eddelbuettel.francois11">2011</a>)</span>.</p>
<div id="enable-c-compiling-for-r" class="section level3">
<h3>Enable <strong>C++</strong> compiling for <strong>R</strong></h3>
<ul>
<li>For Windows, install <a href="https://cran.r-project.org/bin/windows/Rtools/"><strong><code>Rtools</code></strong></a>. Let the installer modify your system variable <code>Path</code>.</li>
<li>For OS X, install the <a href="https://developer.apple.com/library/content/technotes/tn2339/_index.html"><strong><code>Xcode</code></strong> command line tools</a>. To do this, open Terminal and run <code>xcode-select --install</code>. You can simply press “Install” without obtaining the entire Xcode suite.</li>
<li>For Linux, install <code>build-essential</code> and a recent version of <strong><code>g++</code></strong> or <strong><code>clang++</code></strong>.</li>
</ul>
<p>To make sure the <strong>C++</strong> compiler is set up correctly, install the <strong><code>Rcpp</code></strong> package and from within <strong>R</strong> run the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Rcpp::<span class="kw">cppFunction</span>(<span class="st">&quot;double AddTest(double x, double y) {return x + y;}&quot;</span>)
<span class="kw">AddTest</span>(<span class="fl">5.2</span>, <span class="fl">3.4</span>)</code></pre></div>
<p>If the code compiles and outputs 8.6 then the <strong>C++</strong> compiler is interfaced with <strong>R</strong> correctly.</p>
</div>
<div id="optimize-settings-for-the-c-compiler-optional" class="section level3">
<h3>Optimize settings for the <strong>C++</strong> compiler (optional)</h3>
<p>It’s possible to speed up <strong><code>msde</code></strong> by a reasonable amount by passing a few flags to the <strong>C++</strong> compiler. This can be done by creating a <code>Makevars</code> file (or <code>Makevars.win</code> on Windows). To do this, find your home folder by running the <strong>R</strong> command <code>Sys.getenv(&quot;HOME&quot;)</code>, and in that folder create a subfolder called <code>.R</code> containing the <code>Makevars</code> file (if it doesn’t exist already). Now add the following lines to th <code>.R/Makevars</code> file:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="va">CXXFLAGS=</span>-O3 <span class="ex">-ffastmath</span>
<span class="va">CXX=</span>clang++</code></pre></div>
<p>The first two options make the <strong>C++</strong> code faster and the third uses the <strong><code>clang++</code></strong> compiler instead of <strong><code>g++</code></strong>, which has better error messages (and is the default compiler on OS X).</p>
</div>
<div id="enable-openmp-support-optional" class="section level3">
<h3>Enable <strong><code>OpenMP</code></strong> support (optional)</h3>
<p>On a multicore machine, <strong><code>msde</code></strong> can parallelize some of its computations with <strong><code>OpenMP</code></strong> directives. This can’t be done through <strong>R</strong> on Windows and is supported by default on recent versions of <strong><code>g++/clang++</code></strong> on Linux. For OS X, the default version of <strong><code>clang++</code></strong> does not support <strong><code>OpenMP</code></strong> but it is supported by that of the <a href="http://llvm.org/">LLVM Project</a>. This can be installed through <a href="https://brew.sh/">Homebrew</a>. After installing Homebrew using the instructions from the previous link, in Terminal run <code>brew install llvm</code>. Then have <strong>R</strong> use LLVM’s <strong><code>clang++</code></strong> compiler by setting the following in <code>.R/Makevars</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="va">CXXFLAGS=</span>-I/usr/local/opt/llvm/include <span class="ex">-O3</span> -ffast-math
<span class="va">LDFLAGS=</span>-L/usr/local/opt/llvm/lib
<span class="va">CXX=</span>/usr/local/opt/llvm/bin/clang++</code></pre></div>
<p>Note that these compiler directives alone will not enable <strong><code>OpenMP</code></strong> support. This happens at compile time by linking against <code>-fopenmp</code>, which is done internally by <strong><code>msde</code></strong>.</p>
</div>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-eddelbuettel.francois11">
<p>Eddelbuettel, D. and François, R., 2011. Rcpp: Seamless R and C++ integration. <em>Journal of Statistical Software</em>, 40 (8), 1–18.</p>
</div>
<div id="ref-golightly-wilkinson10">
<p>Golightly, A. and Wilkinson, D.J., 2010. Discussion of ‘Particle Markov chain Monte Carlo methods’ by Christophe Andrieu, Arnaud Doucet, Roman Holenstein. <em>JRSS B</em>, 59 (2), 341–357.</p>
</div>
<div id="ref-maruyama55">
<p>Maruyama, G., 1955. Continuous Markov processes and stochastic equations. <em>Rendiconti del Circolo Matematico di Palermo</em>, 4 (1), 48–90.</p>
</div>
<div id="ref-pedersen95">
<p>Pedersen, A.R., 1995. A new approach to maximum likelihood estimation for stochastic differential equations based on discrete observations. <em>Scandinavian Journal of Statistics</em>, 22 (1), 55–71.</p>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

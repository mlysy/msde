<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Martin Lysy" />

<meta name="date" content="2017-05-21" />

<title>Inference for multivariate Stochastic Differential Equations with msde</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Inference for multivariate Stochastic Differential Equations with <strong><code>msde</code></strong></h1>
<h4 class="author"><em>Martin Lysy</em></h4>
<h4 class="date"><em>2017-05-21</em></h4>


<div id="TOC">
<ul>
<li><a href="#installation">Installation</a><ul>
<li><a href="#enable-c-compiling-for-r">Enable <strong>C++</strong> compiling for <strong>R</strong></a></li>
<li><a href="#optimize-settings-for-the-c-compiler-optional">Optimize settings for the <strong>C++</strong> compiler (optional)</a></li>
<li><a href="#enable-openmp-support-optional">Enable <strong><code>OpenMP</code></strong> support (optional)</a></li>
</ul></li>
<li><a href="#stochastic-lotka-volterra-predator-prey-model">Stochastic Lotka-Volterra predator-prey model</a></li>
<li><a href="#compiling-and-checking-the-sdemodel">Compiling and checking the <strong><code>sdeModel</code></strong></a></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<div id="installation" class="section level2">
<h2>Installation</h2>
<p>The <strong><code>msde</code></strong> package requires on-the-fly <strong>C++</strong> compiling of user-specified models which is handled through the <strong>R</strong> package <strong><code>Rcpp</code></strong>.</p>
<div id="enable-c-compiling-for-r" class="section level3">
<h3>Enable <strong>C++</strong> compiling for <strong>R</strong></h3>
<ul>
<li>For Windows, install <a href="https://cran.r-project.org/bin/windows/Rtools/"><strong><code>Rtools</code></strong></a>. Let the installer modify your system variable <code>Path</code>.</li>
<li>For OS X, install the <a href="https://developer.apple.com/library/content/technotes/tn2339/_index.html"><strong><code>Xcode</code></strong> command line tools</a>. To do this, open Terminal and run <code>xcode-select --install</code>. You can simply press “Install” without obtaining the entire Xcode suite.</li>
<li>For Linux, install <code>build-essential</code> and a recent version of <strong><code>g++</code></strong> or <strong><code>clang++</code></strong>.</li>
</ul>
<p>To make sure the <strong>C++</strong> compiler is set up correctly, install the <strong><code>Rcpp</code></strong> package and from within <strong>R</strong> run the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Rcpp<span class="op">::</span><span class="kw">cppFunction</span>(<span class="st">&quot;double AddTest(double x, double y) {return x + y;}&quot;</span>)
<span class="kw">AddTest</span>(<span class="fl">5.2</span>, <span class="fl">3.4</span>)</code></pre></div>
<p>If the code compiles and outputs 8.6 then the <strong>C++</strong> compiler is interfaced with <strong>R</strong> correctly.</p>
</div>
<div id="optimize-settings-for-the-c-compiler-optional" class="section level3">
<h3>Optimize settings for the <strong>C++</strong> compiler (optional)</h3>
<p>It’s possible to speed up <strong><code>msde</code></strong> by a reasonable amount by passing a few flags to the <strong>C++</strong> compiler. This can be done by creating a <code>Makevars</code> file (or <code>Makevars.win</code> on Windows). To do this, find your home folder by running the <strong>R</strong> command <code>Sys.getenv(&quot;HOME&quot;)</code>, and in that folder create a subfolder called <code>.R</code> containing the <code>Makevars</code> file (if it doesn’t exist already). Now add the following lines to th <code>.R/Makevars</code> file:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="va">CXXFLAGS=</span>-O3 <span class="ex">-ffastmath</span>
<span class="va">CXX=</span>clang++</code></pre></div>
<p>The first two options make the <strong>C++</strong> code faster and the third uses the <strong><code>clang++</code></strong> compiler instead of <strong><code>g++</code></strong>, which has better error messages (and is the default compiler on OS X).</p>
</div>
<div id="enable-openmp-support-optional" class="section level3">
<h3>Enable <strong><code>OpenMP</code></strong> support (optional)</h3>
<p>On a multicore machine, <strong><code>msde</code></strong> can parallelize some of its computations with <strong><code>OpenMP</code></strong> directives. This can’t be done through <strong>R</strong> on Windows and is supported by default on recent versions of <strong><code>g++/clang++</code></strong> on Linux. For OS X, the default version of <strong><code>clang++</code></strong> does not support <strong><code>OpenMP</code></strong> but it is supported by that of the <a href="http://llvm.org/">LLVM Project</a>. This can be installed through <a href="https://brew.sh/">Homebrew</a>. After installing Homebrew using the instructions from the previous link, in Terminal run <code>brew install llvm</code>. Then have <strong>R</strong> use LLVM’s <strong><code>clang++</code></strong> compiler by setting the following in <code>.R/Makevars</code>:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="va">CXXFLAGS=</span>-I/usr/local/opt/llvm/include <span class="ex">-O3</span> -ffast-math
<span class="va">LDFLAGS=</span>-L/usr/local/opt/llvm/lib
<span class="va">CXX=</span>/usr/local/opt/llvm/bin/clang++</code></pre></div>
<p>Note that these compiler directives alone will not enable <strong><code>OpenMP</code></strong> support. This happens at compile time by linking against <code>-fopenmp</code>, which is done internally by <strong><code>msde</code></strong>.</p>
</div>
</div>
<div id="stochastic-lotka-volterra-predator-prey-model" class="section level2">
<h2>Stochastic Lotka-Volterra predator-prey model</h2>
<p>Let <span class="math inline">\(H_t\)</span> and <span class="math inline">\(L_t\)</span> denote the number of Hare and Lynx at time <span class="math inline">\(t\)</span> coexisting in a given habitat. An SDE describing the interactions between these two animal populations is given by the following stochastic Lotka-Volterra predator-prey model <span class="citation">(Golightly and Wilkinson <a href="#ref-golightly-wilkinson10">2010</a>)</span>: <span class="math display">\[
\begin{pmatrix} \mathrm{d} H_t \\ \mathrm{d} L_t \end{pmatrix} = \begin{pmatrix} \alpha H_t - \beta H_tL_t \\ \beta H_tL_t - \gamma L_t \end{pmatrix} \mathrm{d} t + \begin{pmatrix} \alpha H_t + \beta H_tL_t &amp; -\beta H_tL_t \\ -\beta H_tL_t &amp; \beta H_tL_t + \gamma L_t\end{pmatrix}^{1/2} \begin{pmatrix} \mathrm{d} B_{1t} \\ \mathrm{d} B_{2t} \end{pmatrix}.
\]</span> In order to build this model in <strong>C++</strong>, we create a header file <code>lotvolModel.h</code> containing the class definition for an <code>sdeModel</code> object. The basic structure of this class is given below:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// sde model object</span>
<span class="kw">class</span> sdeModel {
 <span class="kw">public</span>:
  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> nParams = <span class="dv">3</span>; <span class="co">// number of model parameters</span>
  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> nDims = <span class="dv">2</span>; <span class="co">// number of sde dimensions</span>
  <span class="at">static</span> <span class="at">const</span> <span class="dt">bool</span> sdDiff = <span class="kw">false</span>; <span class="co">// whether diffusion function is on sd or var scale</span>
  <span class="at">static</span> <span class="at">const</span> <span class="dt">bool</span> diagDiff = <span class="kw">false</span>; <span class="co">// whether diffusion function is diagonal</span>
  <span class="dt">void</span> sdeDr(<span class="dt">double</span> *dr, <span class="dt">double</span> *x, <span class="dt">double</span> *theta); <span class="co">// drift function</span>
  <span class="dt">void</span> sdeDf(<span class="dt">double</span> *df, <span class="dt">double</span> *x, <span class="dt">double</span> *theta); <span class="co">// diffusion function</span>
  <span class="dt">bool</span> isValidParams(<span class="dt">double</span> *theta); <span class="co">// parameter validator</span>
  <span class="dt">bool</span> isValidData(<span class="dt">double</span> *x, <span class="dt">double</span> *theta); <span class="co">// data validator</span>
};</code></pre></div>
<p>The meaning of each class member is as follows:</p>
<ul>
<li><code>nParams</code>: The number of model parameters. For the Lotka-Volterra model we have <span class="math inline">\({\boldsymbol{\theta}}= ({\alpha}, {\beta}, {\gamma})\)</span>, such that <code>nParams = 3</code>.</li>
<li><code>nDims</code>: The number of dimensions in the multivariate SDE. In this case we have <span class="math inline">\({\boldsymbol{Y}}_t = (H_t, L_t)\)</span>, such that <code>nDims = 2</code>.</li>
<li><p><code>sdeDr</code>: The SDE drift function. In <strong>R</strong>, this function would be implemented as</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sde.drift &lt;-<span class="st"> </span><span class="cf">function</span>(x, theta) {
  dr &lt;-<span class="st"> </span><span class="kw">c</span>(theta[<span class="dv">1</span>]<span class="op">*</span>x[<span class="dv">1</span>] <span class="op">-</span><span class="st"> </span>theta[<span class="dv">2</span>]<span class="op">*</span>x[<span class="dv">1</span>]<span class="op">*</span>x[<span class="dv">2</span>], <span class="co"># alpha * H - beta * H * L</span>
      theta[<span class="dv">2</span>]<span class="op">*</span>x[<span class="dv">1</span>]<span class="op">*</span>x[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>theta[<span class="dv">3</span>]<span class="op">*</span>x[<span class="dv">2</span>]) <span class="co"># beta * H * L - gamma * L</span>
  dr
}</code></pre></div>
<p>In <strong>C++</strong> the same thing is accomplished with</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> sdeDr(<span class="dt">double</span> *dr, <span class="dt">double</span> *x, <span class="dt">double</span> *theta) {
  dr[<span class="dv">0</span>] = theta[<span class="dv">0</span>]*x[<span class="dv">0</span>] - theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>]; <span class="co">// alpha * H - beta * H * L</span>
  dr[<span class="dv">1</span>] = theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>] - theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]; <span class="co">// beta * H * L - gamma * L</span>
  <span class="cf">return</span>;
}</code></pre></div></li>
<li><p><code>sdeDf</code>: The SDE diffusion function. This can be specified on the standard deviation scale, or on the variance scale as above. In this case, an <strong>R</strong> implementation would be</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sde.diff &lt;-<span class="st"> </span><span class="cf">function</span>(x, theta) {
  df &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, <span class="dv">2</span>, <span class="dv">2</span>)
  df[<span class="dv">1</span>,<span class="dv">1</span>] &lt;-<span class="st"> </span>theta[<span class="dv">1</span>]<span class="op">*</span>x[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>theta[<span class="dv">2</span>]<span class="op">*</span>x[<span class="dv">1</span>]<span class="op">*</span>x[<span class="dv">2</span>] <span class="co"># alpha * H + beta * H * L</span>
  df[<span class="dv">1</span>,<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="op">-</span>theta[<span class="dv">2</span>]<span class="op">*</span>x[<span class="dv">1</span>]<span class="op">*</span>x[<span class="dv">2</span>] <span class="co"># -beta * H * L</span>
  df[<span class="dv">2</span>,<span class="dv">1</span>] &lt;-<span class="st"> </span>df[<span class="dv">1</span>,<span class="dv">2</span>] <span class="co"># -beta * H * L</span>
  df[<span class="dv">2</span>,<span class="dv">2</span>] &lt;-<span class="st"> </span>theta[<span class="dv">2</span>]<span class="op">*</span>x[<span class="dv">1</span>]<span class="op">*</span>x[<span class="dv">2</span>] <span class="op">+</span><span class="st"> </span>theta[<span class="dv">3</span>]<span class="op">*</span>x[<span class="dv">2</span>] <span class="co"># beta * H * L + gamma * L</span>
  df
}</code></pre></div>
<p>In <strong>C++</strong> the specification is slightly different. First we set <code>sdDiff = false</code> in order to tell <strong><code>msde</code></strong> to use the variance scale. Next, the diffusion function is coded as</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> sdeDf(<span class="dt">double</span> *df, <span class="dt">double</span> *x, <span class="dt">double</span> *theta) {
  df[<span class="dv">0</span>] = theta[<span class="dv">0</span>]*x[<span class="dv">0</span>] + theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>]; <span class="co">// matrix element (1,1)</span>
  df[<span class="dv">2</span>] = -theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>]; <span class="co">// element (1,2)</span>
  df[<span class="dv">3</span>] = theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>] + theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]; <span class="co">// element (2,2)</span>
  <span class="cf">return</span>;
}</code></pre></div>
<p>Thus there are two major differences with the <strong>R</strong> version. The first is that the <code>df</code> matrix is stored as a vector (or “array” in <strong>C++</strong>). Its elements are stored in column-major order, i.e., by stacking the columns one after the other into one long vector. The second difference is that <strong><code>msde</code></strong> only uses the <em>upper triangular</em> portion of the (symmetric) variance matrix. The elements below the diagonal can be set to any value or not set at all without affecting the computations.</p>
<p><strong><code>msde</code></strong> internally computes the Cholesky decomposition of the diffusion function when it is specified on the variance scale. For small problems such as this one, it is more efficient to specify the Cholesky decomposition directly, i.e., specify the diffusion on the standard deviation scale. In this case, the Cholesky decomposition of the diffusion function is <span class="math display">\[
\begin{pmatrix} \alpha H_t + \beta H_tL_t &amp; -\beta H_tL_t \\ -\beta H_tL_t &amp; \beta H_tL_t + \gamma L_t\end{pmatrix}^{1/2} = \begin{pmatrix} \sqrt{{\alpha}H_t + {\beta}H_tL_t} &amp; -\frac{{\beta}H_tL_t}{\sqrt{{\alpha}H_t + {\beta}H_tL_t}} \\ 0 &amp; \sqrt{{\beta}H_tL_t - {\gamma}L_t - \frac{({\beta}H_tL_t)^2}{{\alpha}H_t + {\beta}H_tL_t}} \end{pmatrix},
\]</span> which is passed to <strong><code>msde</code></strong> by setting <code>sdDiff = true</code> and</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> sdeDf(<span class="dt">double</span> *df, <span class="dt">double</span> *x, <span class="dt">double</span> *theta) {
  <span class="dt">double</span> bHL = theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>]; <span class="co">// beta*H*L</span>
  df[<span class="dv">0</span>] = sqrt(theta[<span class="dv">0</span>]*x[<span class="dv">0</span>] + bHL); <span class="co">// sqrt(alpha*H + bHL)</span>
  df[<span class="dv">2</span>] = -bHL/df[<span class="dv">0</span>];
  df[<span class="dv">3</span>] = sqrt(bHL - theta[<span class="dv">2</span>]*x[<span class="dv">1</span>] - df[<span class="dv">2</span>]*df[<span class="dv">2</span>]);
  <span class="cf">return</span>;
}</code></pre></div>
<strong>TODO:</strong> <code>diagDiff</code> for diagonal diffusion functions.</li>
<li><p><code>isValidParams</code>: A logical used to specify the parameter support. In this case we have <span class="math inline">\({\alpha}, {\beta}, {\gamma}&gt; 0\)</span>, such that</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> isValidParams(<span class="dt">double</span> *theta) {
  <span class="dt">bool</span> val = theta[<span class="dv">0</span>] &gt; <span class="fl">0.0</span>;
  val = val &amp;&amp; theta[<span class="dv">1</span>] &gt; <span class="fl">0.0</span>;
  val = val ** theta[<span class="dv">2</span>] &gt; <span class="fl">0.0</span>;
  <span class="cf">return</span> val;
}</code></pre></div></li>
<li><p><code>isValidData</code>: A logical used to specify the SDE support, which can be parameter-dependent. In this case we simply have <span class="math inline">\(H_t, L_t &gt; 0\)</span>, such that</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> isValidData(<span class="dt">double</span> *x, <span class="dt">double</span> *theta) {
  <span class="cf">return</span> (x[<span class="dv">0</span>] &gt; <span class="fl">0.0</span>) &amp;&amp; (x[<span class="dv">1</span>] &gt; <span class="fl">0.0</span>);
}</code></pre></div></li>
</ul>
<p>Thus the whole file <code>lotvolModel.h</code> is given below:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifndef sdeModel_h</span>
<span class="pp">#define sdeModel_h 1</span>

<span class="co">// Lotka-Volterra Predator-Prey model</span>

<span class="co">// class definition</span>
<span class="kw">class</span> sdeModel {
 <span class="kw">public</span>:
  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> nParams = <span class="dv">3</span>; <span class="co">// number of model parameters</span>
  <span class="at">static</span> <span class="at">const</span> <span class="dt">int</span> nDims = <span class="dv">2</span>; <span class="co">// number of sde dimensions</span>
  <span class="at">static</span> <span class="at">const</span> <span class="dt">bool</span> diagDiff = <span class="kw">false</span>; <span class="co">// whether diffusion function is diagonal</span>
  <span class="at">static</span> <span class="at">const</span> <span class="dt">bool</span> sdDiff = <span class="kw">true</span>; <span class="co">// whether diffusion is on sd or var scale</span>
  <span class="dt">void</span> sdeDr(<span class="dt">double</span> *dr, <span class="dt">double</span> *x, <span class="dt">double</span> *theta); <span class="co">// drift function</span>
  <span class="dt">void</span> sdeDf(<span class="dt">double</span> *df, <span class="dt">double</span> *x, <span class="dt">double</span> *theta); <span class="co">// diffusion function</span>
  <span class="dt">bool</span> isValidParams(<span class="dt">double</span> *theta); <span class="co">// parameter validator</span>
  <span class="dt">bool</span> isValidData(<span class="dt">double</span> *x, <span class="dt">double</span> *theta); <span class="co">// data validator</span>
};

<span class="co">// drift function</span>
<span class="kw">inline</span> <span class="dt">void</span> sdeDr(<span class="dt">double</span> *dr, <span class="dt">double</span> *x, <span class="dt">double</span> *theta) {
  dr[<span class="dv">0</span>] = theta[<span class="dv">0</span>]*x[<span class="dv">0</span>] - theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>]; <span class="co">// alpha*H - beta*H*L</span>
  dr[<span class="dv">1</span>] = theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>] - theta[<span class="dv">2</span>]*x[<span class="dv">1</span>]; <span class="co">// beta*H*L - gamma*L</span>
  <span class="cf">return</span>;
}

<span class="co">// diffusion function (sd scale)</span>
<span class="kw">inline</span> <span class="dt">void</span> sdeDf(<span class="dt">double</span> *df, <span class="dt">double</span> *x, <span class="dt">double</span> *theta) {
  <span class="dt">double</span> bHL = theta[<span class="dv">1</span>]*x[<span class="dv">0</span>]*x[<span class="dv">1</span>]; <span class="co">// beta*H*L</span>
  df[<span class="dv">0</span>] = sqrt(theta[<span class="dv">0</span>]*x[<span class="dv">0</span>] + bHL); <span class="co">// sqrt(alpha*H + bHL)</span>
  df[<span class="dv">2</span>] = -bHL/df[<span class="dv">0</span>];
  df[<span class="dv">3</span>] = sqrt(bHL - theta[<span class="dv">2</span>]*x[<span class="dv">1</span>] - df[<span class="dv">2</span>]*df[<span class="dv">2</span>]);
  <span class="cf">return</span>;
}

<span class="co">// parameter validator</span>
<span class="kw">inline</span> <span class="dt">bool</span> isValidParams(<span class="dt">double</span> *theta) {
  <span class="dt">bool</span> val = theta[<span class="dv">0</span>] &gt; <span class="fl">0.0</span>;
  val = val &amp;&amp; theta[<span class="dv">1</span>] &gt; <span class="fl">0.0</span>;
  val = val ** theta[<span class="dv">2</span>] &gt; <span class="fl">0.0</span>;
  <span class="cf">return</span> val;
}

<span class="co">// data validator</span>
<span class="kw">inline</span> <span class="dt">bool</span> isValidData(<span class="dt">double</span> *x, <span class="dt">double</span> *theta) {
  <span class="cf">return</span> (x[<span class="dv">0</span>] &gt; <span class="fl">0.0</span>) &amp;&amp; (x[<span class="dv">1</span>] &gt; <span class="fl">0.0</span>);
}

<span class="pp">#endif</span></code></pre></div>
<p>The only additions to the previous code sections are (i) the header include guards (<code>#ifndef</code>/<code>#define</code>/<code>#endif</code>) and (ii) the <code>inline</code> keyword before the class member definitions, both of which ensure that only one instance of these functions is passed to the <strong>C++</strong> compiler.</p>
</div>
<div id="compiling-and-checking-the-sdemodel" class="section level2">
<h2>Compiling and checking the <strong><code>sdeModel</code></strong></h2>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-golightly-wilkinson10">
<p>Golightly, Andrew, and Darren J Wilkinson. 2010. “Discussion of ‘Particle Markov Chain Monte Carlo Methods’ by Christophe Andrieu, Arnaud Doucet, Roman Holenstein.” <em>JRSS B</em> 59 (2): 341–57.</p>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

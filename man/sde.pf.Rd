% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sde.pf.R
\name{sde.pf}
\alias{sde.pf}
\title{Particle filter for SDE model.}
\usage{
sde.pf(model, init, npart, resample = c("multi", "resid", "strat", "sys"),
  threshold = 0.5, Z, history = FALSE)
}
\arguments{
\item{model}{An \code{sde.model} object.}

\item{init}{Initialization of SDE.}

\item{npart}{Number of particles.}

\item{resample}{The type of particle resampling scheme to use. These are: multi(nomial), resid(ual), strat(ified), sys(tematic).}

\item{threshold}{A scalar less than 1 to indicate the threshold for resampling. A negative number disables resampling.}

\item{Z}{Optional array of dimensions \code{(ncomp - 1) x ndims x npart} providing the standard normal draws for the filter to use.  This is most useful for debugging, in conjunction with setting \code{threshold} to a negative value.}

\item{history}{Logical; whether or not the entire history of the particle filter should be output, or only draws for the last observation.}
}
\value{
A list with elements:
\describe{
  \item{\code{data}}{If \code{history = FALSE}, a \code{npart x ndims} matrix of particles for the last observation.  If \code{history = TRUE}, an array of dimension \code{npart x ndims x nComp}.}
  \item{\code{lgwt}}{If \code{history = FALSE}, a \code{npart}-length vector of unnormalized log weights for the last observation.  Otherwise a matrix of dimension \code{npart x nComp}.}
}
}
\description{
Particle filter for SDE model.
}
\details{
\code{sde.pf} is just a wrapper of the \code{C++} level member function \code{particleEval} of \code{sdeRobj<sMod, sPi>} class type. Sequential Monte Carlo (currently only particle filtering not smoothing) methods are implemented (at C++ level) to output the values of particles and unnormalized log weights.  
Consider a general State-Space Model with static parameters \eqn{\theta} (which may be multidimensional) consists of a hidden state process \eqn{{X_n}_{n \geq 1}}$ and a observation process \eqn{{Y_n}_{n \geq 1}}. Once the unnormalized log weights are obtained, users can build up their own particle MCMC by using the following approximation
\deqn{
\hat{p}_\theta(y_{1:T}) = \frac{1}{N} \sum_{i=1}^N w(X_{1:T}^i)
}{
\hat{p}_\theta(y_{1:T}) = 1/N*( w(X_{1:T}^1) + ... + w(X_{1:T}^N) )
}
that is, to do MCMC on \eqn{p(\theta | y_{1:T})} directly. \eqn{T} is the total observation time. \eqn{N} is total number of particles.
}
\examples{
# load pre-compiled model
emod <- sde.examples("eou")

# initial parameters
theta0 <- c(alpha = .1, gamma = 1, eta = .3, sigma = .2, rho = -.63)
# number of observations
nObs <- 100
# number of dimensions
nDims <- emod$ndims
# time between observations (1 year has about 252 trading days)
dt <- 1/252
# internal observation time
dt.sim <- dt/10
# initial SDE values
Y0 <- c(X = rnorm(1), V = rnorm(1))
# simulate SDE data
esim <- sde.sim(emod, x0 = Y0, theta = theta0,
                nobs = nObs, # nObs steps forward
                dt = dt, dt.sim = dt/10)
# initialization
minit <- sde.init(emod, x = esim$data, dt = dt, theta = theta0,
                 nvar.obs = sample(nDims, nObs, replace = TRUE), m = 1)

# number of particles
nPart <- 37
Z <- array(rnorm(nPart*nDims*(nObs-1)), c(nObs-1, nDims, nPart))
# particle filter (without pre-specified Z)
pf <- sde.pf(emod, init = minit, npart = nPart,
             resample = "multi", threshold = -1,
             Z = Z, history = TRUE)
# output the last observation and normalized log-weights
data <- pf$data
lwgt <- pf$lwgt

}
